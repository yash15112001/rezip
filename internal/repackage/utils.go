package repackage

import (
	"archive/zip"
	"crypto/sha256"
	"encoding/binary"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// Windows NTFS-specific constants for symlink detection in ZIP extra fields.
const (
	// NTFS Extra field identifier in ZIP file format.
	ntfsExtraID = 0x000A

	// Windows reparse point tag for symbolic links.
	ioReparseSymlink = 0xA000000C

	// Windows reparse point tag for mount points.
	ioReparseMount = 0xA0000003
)

func areFileHashesIdentical(file1, file2 *zip.File) (bool, error) {
	hash1, err := HashOf(file1)
	if err != nil {
		return false, err
	}
	hash2, err := HashOf(file2)
	if err != nil {
		return false, err
	}
	return hash1 == hash2, nil
}

// isSymlink detects if a ZIP entry is a symbolic link, which should be excluded during flattening.
// It handles both Unix-style symlinks and Windows NTFS reparse points.
//
// Symlinks in a flattened archive could point to invalid locations or create security risks,
// so they're excluded during the deduplication process.
func isSymlink(file *zip.File) bool {
	// Check standard Unix symlink bit in file mode.
	if file.Mode()&os.ModeSymlink != 0 {
		return true
	}

	// Parse ZIP extra field data for Windows NTFS reparse points.
	extraData := file.Extra

	// Need at least 4 bytes for header (2 for ID, 2 for size).
	for len(extraData) >= 4 {
		// Extra field header: 2-byte ID followed by 2-byte size
		fieldID := binary.LittleEndian.Uint16(extraData[0:2])
		fieldSize := binary.LittleEndian.Uint16(extraData[2:4])

		// Check if this is an NTFS extra field and we have enough data to read it.
		if fieldID == ntfsExtraID && int(fieldSize)+4 <= len(extraData) {
			// NTFS field contains a tag value at offset 4-8 that identifies the type
			tag := binary.LittleEndian.Uint32(extraData[4:8])

			if tag == ioReparseSymlink || tag == ioReparseMount {
				return true
			}
		}

		// Advance to next extra field.
		advance := int(4 + fieldSize)
		if advance > len(extraData) {
			break
		}
		extraData = extraData[advance:]
	}

	return false
}

// isMetadataFile identifies few of the system and application metadata files that should be excluded
// during deduplication. These files:
//
// 1. Often have identical names but different content across directories.
// 2. Could cause false content conflicts when flattened.
// 3. Typically store hierarchical information that loses meaning when flattened.
// 4. May be tied to specific directory structures that no longer exist after flattening.
// 5. Don't contain user data and are automatically generated by operating systems or applications.
//
// LIMITATION: This function only recognizes well-known metadata files. There may be many other
// metadata files from various applications or systems that aren't detected.
func isMetadataFile(fileName string) bool {
	baseName := filepath.Base(fileName)

	// macOS metadata files - these commonly appear with same names in different directories.
	if strings.HasPrefix(fileName, "__MACOSX/") ||
		baseName == ".DS_Store" ||
		strings.HasPrefix(baseName, "._") {
		return true
	}

	// Windows thumbnail caches - can appear in multiple directories.
	if baseName == "Thumbs.db" ||
		baseName == "Desktop.ini" {
		return true
	}

	// Common temp files that might appear with same names in different locations.
	if strings.HasPrefix(baseName, "~$") ||
		strings.HasSuffix(baseName, ".tmp") {
		return true
	}

	return false
}

func HashOf(file *zip.File) ([32]byte, error) {
	reader, err := file.Open()
	if err != nil {
		return [32]byte{}, err
	}
	defer reader.Close()

	// Creates a SHA-256 hash calculator.
	hashCalculator := sha256.New()
	if _, err := io.Copy(hashCalculator, reader); err != nil {
		return [32]byte{}, err
	}

	var hash [32]byte
	copy(hash[:], hashCalculator.Sum(nil))
	return hash, nil
}

// writeAndHashEntry writes a ZIP entry uncompressed and computes its SHA-256.
func writeAndHashEntry(zipWriter *zip.Writer, file *zip.File, name string) ([32]byte, error) {
	fileReader, err := file.Open()
	if err != nil {
		return [32]byte{}, err
	}
	defer fileReader.Close()

	// Prepare header for store mode (no compression).
	header := &zip.FileHeader{
		Name:   name,
		Method: zip.Store,
	}

	zipFileWriter, err := zipWriter.CreateHeader(header)
	if err != nil {
		return [32]byte{}, err
	}

	// Set up multi-writer for zip entry and hasher.
	hashCalculator := sha256.New()
	multiWriter := io.MultiWriter(zipFileWriter, hashCalculator)

	if _, err := io.Copy(multiWriter, fileReader); err != nil {
		return [32]byte{}, err
	}

	var hash [32]byte
	copy(hash[:], hashCalculator.Sum(nil))
	return hash, nil
}
